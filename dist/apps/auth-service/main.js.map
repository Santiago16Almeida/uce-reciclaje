{"version":3,"file":"main.js","mappings":";;;;;;;AAAA,yC;;;;;;ACAA,kD;;;;;;ACAA,iC;;;;;;ACAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,gBAAgB,mBAAO,CAAC,CAAO;AAC/B,iBAAiB,mBAAO,CAAC,CAAgB;AACzC,kBAAkB,mBAAO,CAAC,CAAiB;AAC3C,yBAAyB,mBAAO,CAAC,CAAkB;AACnD,sBAAsB,mBAAO,CAAC,CAAe;AAC7C,sBAAsB,mBAAO,CAAC,EAAe;AAC7C;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;AC/BA,kC;;;;;;ACAA,2C;;;;;;ACAA,4C;;;;;;ACAa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,gBAAgB,mBAAO,CAAC,CAAO;AAC/B,iBAAiB,mBAAO,CAAC,CAAgB;AACzC,wBAAwB,mBAAO,CAAC,CAAuB;AACvD,sBAAsB,mBAAO,CAAC,CAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;;;;;;ACnDa;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,gBAAgB,mBAAO,CAAC,CAAO;AAC/B,iBAAiB,mBAAO,CAAC,CAAgB;AACzC,kBAAkB,mBAAO,CAAC,CAAiB;AAC3C,kBAAkB,mBAAO,CAAC,EAAS;AACnC,sBAAsB,mBAAO,CAAC,EAAe;AAC7C,0CAA0C,mBAAO,CAAC,EAAS;AAC3D,oCAAoC,mBAAO,CAAC,EAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+DAA+D,SAAS,qBAAqB;AAC7F;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mFAAmF,WAAW;AAC9F,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,oBAAoB,qCAAqC;AAC/G;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,2DAA2D,WAAW;AACtE;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;;;;;;;ACpGA,oC;;;;;;ACAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,gBAAgB,mBAAO,CAAC,CAAO;AAC/B,kBAAkB,mBAAO,CAAC,EAAS;AACnC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,gBAAgB;AAChB;AACA;;;;;;;AC1BA,oC;;;;;;ACAA,mC;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,mBAAO,CAAC,CAAc;AACrC,wBAAwB,mBAAO,CAAC,CAAuB;AACvD,eAAe,mBAAO,CAAC,CAAM;AAC7B,qBAAqB,mBAAO,CAAC,CAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA","sources":["external commonjs \"@nestjs/core\"","external commonjs \"@nestjs/microservices\"","external node-commonjs \"path\"","C:\\Users\\IntelCore i5\\uce-reciclaje\\apps\\auth-service\\src\\app\\app.module.ts","external commonjs \"tslib\"","external commonjs \"@nestjs/common\"","external commonjs \"@nestjs/typeorm\"","C:\\Users\\IntelCore i5\\uce-reciclaje\\apps\\auth-service\\src\\app\\app.controller.ts","C:\\Users\\IntelCore i5\\uce-reciclaje\\apps\\auth-service\\src\\app\\app.service.ts","external commonjs \"typeorm\"","C:\\Users\\IntelCore i5\\uce-reciclaje\\apps\\auth-service\\src\\app\\auth.entity.ts","external commonjs \"ioredis\"","external commonjs \"bcrypt\"","webpack/bootstrap","C:\\Users\\IntelCore i5\\uce-reciclaje\\apps\\auth-service\\src\\main.ts"],"sourcesContent":["module.exports = require(\"@nestjs/core\");","module.exports = require(\"@nestjs/microservices\");","module.exports = require(\"path\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppModule = void 0;\nconst tslib_1 = require(\"tslib\");\nconst common_1 = require(\"@nestjs/common\");\nconst typeorm_1 = require(\"@nestjs/typeorm\");\nconst app_controller_1 = require(\"./app.controller\");\nconst app_service_1 = require(\"./app.service\");\nconst auth_entity_1 = require(\"./auth.entity\");\nlet AppModule = class AppModule {\n};\nexports.AppModule = AppModule;\nexports.AppModule = AppModule = tslib_1.__decorate([\n    (0, common_1.Module)({\n        imports: [\n            typeorm_1.TypeOrmModule.forRoot({\n                type: 'postgres',\n                // En AWS usamos el bridge de Docker para llegar al contenedor de Postgres\n                host: process.env.DB_HOST || '172.17.0.1',\n                port: parseInt(process.env.DB_PORT) || 5433,\n                username: 'uce_admin',\n                password: 'uce_password',\n                database: 'uce_users_db',\n                entities: [auth_entity_1.UserAuth],\n                synchronize: true,\n            }),\n            typeorm_1.TypeOrmModule.forFeature([auth_entity_1.UserAuth]),\n        ],\n        controllers: [app_controller_1.AppController],\n        providers: [app_service_1.AppService],\n    })\n], AppModule);\n","module.exports = require(\"tslib\");","module.exports = require(\"@nestjs/common\");","module.exports = require(\"@nestjs/typeorm\");","\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppController = void 0;\nconst tslib_1 = require(\"tslib\");\nconst common_1 = require(\"@nestjs/common\");\nconst microservices_1 = require(\"@nestjs/microservices\");\nconst app_service_1 = require(\"./app.service\");\nlet AppController = class AppController {\n    constructor(appService) {\n        this.appService = appService;\n    }\n    async validateToken(data) {\n        const result = await this.appService.validateToken(data);\n        return {\n            valid: result.valid,\n            userId: result.userId || '',\n            role: result.role || ''\n        };\n    }\n    async register(data) {\n        return await this.appService.register(data);\n    }\n    async login(data) {\n        return await this.appService.login(data);\n    }\n};\nexports.AppController = AppController;\ntslib_1.__decorate([\n    (0, microservices_1.GrpcMethod)('AuthService', 'ValidateToken'),\n    tslib_1.__metadata(\"design:type\", Function),\n    tslib_1.__metadata(\"design:paramtypes\", [Object]),\n    tslib_1.__metadata(\"design:returntype\", Promise)\n], AppController.prototype, \"validateToken\", null);\ntslib_1.__decorate([\n    (0, microservices_1.MessagePattern)({ cmd: 'register_auth' }),\n    tslib_1.__param(0, (0, microservices_1.Payload)()),\n    tslib_1.__metadata(\"design:type\", Function),\n    tslib_1.__metadata(\"design:paramtypes\", [Object]),\n    tslib_1.__metadata(\"design:returntype\", Promise)\n], AppController.prototype, \"register\", null);\ntslib_1.__decorate([\n    (0, microservices_1.MessagePattern)({ cmd: 'login' }),\n    tslib_1.__param(0, (0, microservices_1.Payload)()),\n    tslib_1.__metadata(\"design:type\", Function),\n    tslib_1.__metadata(\"design:paramtypes\", [Object]),\n    tslib_1.__metadata(\"design:returntype\", Promise)\n], AppController.prototype, \"login\", null);\nexports.AppController = AppController = tslib_1.__decorate([\n    (0, common_1.Controller)(),\n    tslib_1.__metadata(\"design:paramtypes\", [typeof (_a = typeof app_service_1.AppService !== \"undefined\" && app_service_1.AppService) === \"function\" ? _a : Object])\n], AppController);\n","\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppService = void 0;\nconst tslib_1 = require(\"tslib\");\nconst common_1 = require(\"@nestjs/common\");\nconst typeorm_1 = require(\"@nestjs/typeorm\");\nconst typeorm_2 = require(\"typeorm\");\nconst auth_entity_1 = require(\"./auth.entity\");\nconst ioredis_1 = tslib_1.__importDefault(require(\"ioredis\"));\nconst bcrypt = tslib_1.__importStar(require(\"bcrypt\"));\nlet AppService = class AppService {\n    constructor(authRepository) {\n        this.authRepository = authRepository;\n        // Configuraci√≥n de Redis para manejo de errores\n        this.redis = new ioredis_1.default({\n            host: 'localhost',\n            port: 6379,\n            lazyConnect: true,\n            maxRetriesPerRequest: 1\n        });\n        this.redis.on('error', () => console.warn('‚ö†Ô∏è Redis fuera de l√≠nea. Las sesiones no se persistir√°n pero el login funcionar√°.'));\n    }\n    async register(data) {\n        try {\n            const exists = await this.authRepository.findOne({ where: { email: data.email } });\n            if (exists)\n                return { status: 'Error', message: 'El usuario ya existe en Auth' };\n            // Encriptar la contrase√±a\n            const salt = await bcrypt.genSalt(10);\n            const hashedPassword = await bcrypt.hash(data.password, salt);\n            const newUser = this.authRepository.create({\n                email: data.email,\n                password: hashedPassword,\n                role: data.role || 'estudiante'\n            });\n            await this.authRepository.save(newUser);\n            console.log(`[Auth-Service] ‚úÖ Credenciales encriptadas creadas para: ${data.email}`);\n            return { status: 'Success', message: 'Credenciales guardadas con √©xito' };\n        }\n        catch (e) {\n            console.error('‚ùå Error en registro:', e.message);\n            return { status: 'Error', message: 'Error al acceder a la base de datos' };\n        }\n    }\n    async login(credentials) {\n        try {\n            const user = await this.authRepository.findOne({\n                where: { email: credentials.email }\n            });\n            if (!user) {\n                return { status: 'Error', message: 'Usuario no registrado en el sistema de autenticaci√≥n' };\n            }\n            // Comparar contrase√±a ingresada con el hash de la DB\n            const isMatch = await bcrypt.compare(credentials.password, user.password);\n            if (!isMatch) {\n                return { status: 'Error', message: 'Contrase√±a incorrecta' };\n            }\n            // Generar Token\n            const token = 'jwt_' + Math.random().toString(36).substring(2, 15);\n            // Intentar guardar en Redis para persistencia de sesi√≥n\n            try {\n                await this.redis.set(`session:${token}`, JSON.stringify({ userId: user.email, role: user.role }), 'EX', 3600);\n            }\n            catch (e) {\n                console.warn('‚ö†Ô∏è No se pudo guardar sesi√≥n en Redis, procediendo con bypass.');\n            }\n            console.log(`[Auth-Service] üîë Login exitoso: ${user.email}`);\n            return {\n                status: 'Success',\n                token,\n                role: user.role,\n                email: user.email\n            };\n        }\n        catch (error) {\n            console.error('‚ùå Error en login:', error.message);\n            return { status: 'Error', message: 'Error interno en el servidor de autenticaci√≥n' };\n        }\n    }\n    async validateToken(data) {\n        if (data.token.startsWith('jwt_'))\n            return { valid: true, userId: 'session_active', role: 'user' };\n        try {\n            const result = await this.redis.get(`session:${data.token}`);\n            if (!result)\n                return { valid: false };\n            const parsed = JSON.parse(result);\n            return { valid: true, userId: parsed.userId, role: parsed.role };\n        }\n        catch (error) {\n            return { valid: false };\n        }\n    }\n};\nexports.AppService = AppService;\nexports.AppService = AppService = tslib_1.__decorate([\n    (0, common_1.Injectable)(),\n    tslib_1.__param(0, (0, typeorm_1.InjectRepository)(auth_entity_1.UserAuth)),\n    tslib_1.__metadata(\"design:paramtypes\", [typeof (_a = typeof typeorm_2.Repository !== \"undefined\" && typeorm_2.Repository) === \"function\" ? _a : Object])\n], AppService);\n","module.exports = require(\"typeorm\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserAuth = void 0;\nconst tslib_1 = require(\"tslib\");\nconst typeorm_1 = require(\"typeorm\");\nlet UserAuth = class UserAuth {\n};\nexports.UserAuth = UserAuth;\ntslib_1.__decorate([\n    (0, typeorm_1.PrimaryGeneratedColumn)(),\n    tslib_1.__metadata(\"design:type\", Number)\n], UserAuth.prototype, \"id\", void 0);\ntslib_1.__decorate([\n    (0, typeorm_1.Column)({ unique: true }),\n    tslib_1.__metadata(\"design:type\", String)\n], UserAuth.prototype, \"email\", void 0);\ntslib_1.__decorate([\n    (0, typeorm_1.Column)(),\n    tslib_1.__metadata(\"design:type\", String)\n], UserAuth.prototype, \"password\", void 0);\ntslib_1.__decorate([\n    (0, typeorm_1.Column)({ default: 'estudiante' }),\n    tslib_1.__metadata(\"design:type\", String)\n], UserAuth.prototype, \"role\", void 0);\nexports.UserAuth = UserAuth = tslib_1.__decorate([\n    (0, typeorm_1.Entity)('auth_credentials')\n], UserAuth);\n","module.exports = require(\"ioredis\");","module.exports = require(\"bcrypt\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"@nestjs/core\");\nconst microservices_1 = require(\"@nestjs/microservices\");\nconst path_1 = require(\"path\");\nconst app_module_1 = require(\"./app/app.module\");\nasync function bootstrap() {\n    const app = await core_1.NestFactory.create(app_module_1.AppModule);\n    // gRPC - Canal de seguridad\n    app.connectMicroservice({\n        transport: microservices_1.Transport.GRPC,\n        options: {\n            package: 'auth',\n            protoPath: (0, path_1.join)(__dirname, 'assets', 'auth.proto'),\n            url: '0.0.0.0:50051',\n        },\n    });\n    // TCP - Canal para el Gateway\n    app.connectMicroservice({\n        transport: microservices_1.Transport.TCP,\n        options: { host: '0.0.0.0', port: 4001 },\n    });\n    await app.startAllMicroservices();\n    await app.listen(4003, '0.0.0.0');\n    console.log('‚úÖ Auth-Service: TCP en 4001 | gRPC en 50051');\n}\nbootstrap();\n"],"names":[],"ignoreList":[],"sourceRoot":""}